
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>app_sensor.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &quot;app_config.h&quot;</a>
<a name="ln2">#include &quot;app_comms.h&quot;</a>
<a name="ln3">#include &quot;app_log.h&quot;</a>
<a name="ln4">#include &quot;app_sensor.h&quot;</a>
<a name="ln5">#include &quot;ruuvi_boards.h&quot;</a>
<a name="ln6">#include &quot;ruuvi_driver_error.h&quot;</a>
<a name="ln7">#include &quot;ruuvi_driver_sensor.h&quot;</a>
<a name="ln8">#include &quot;ruuvi_endpoints.h&quot;</a>
<a name="ln9">#include &quot;ruuvi_interface_communication_radio.h&quot;</a>
<a name="ln10">#include &quot;ruuvi_interface_gpio.h&quot;</a>
<a name="ln11">#include &quot;ruuvi_interface_gpio_interrupt.h&quot;</a>
<a name="ln12">#include &quot;ruuvi_interface_i2c.h&quot;</a>
<a name="ln13">#include &quot;ruuvi_interface_bme280.h&quot;</a>
<a name="ln14">#include &quot;ruuvi_interface_lis2dh12.h&quot;</a>
<a name="ln15">#include &quot;ruuvi_interface_adc_ntc.h&quot;</a>
<a name="ln16">#include &quot;ruuvi_interface_adc_photo.h&quot;</a>
<a name="ln17">#include &quot;ruuvi_interface_log.h&quot;</a>
<a name="ln18">#include &quot;ruuvi_interface_rtc.h&quot;</a>
<a name="ln19">#include &quot;ruuvi_interface_shtcx.h&quot;</a>
<a name="ln20">#include &quot;ruuvi_interface_spi.h&quot;</a>
<a name="ln21">#include &quot;ruuvi_interface_yield.h&quot;</a>
<a name="ln22">#include &quot;ruuvi_task_adc.h&quot;</a>
<a name="ln23">#include &quot;ruuvi_task_sensor.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;string.h&gt;</a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">static inline void LOG (const char * const msg)</a>
<a name="ln29">{</a>
<a name="ln30">    ri_log (RI_LOG_LEVEL_INFO, msg);</a>
<a name="ln31">}</a>
<a name="ln32"> </a>
<a name="ln33">static inline void LOGD (const char * const msg)</a>
<a name="ln34">{</a>
<a name="ln35">    ri_log (RI_LOG_LEVEL_DEBUG, msg);</a>
<a name="ln36">}</a>
<a name="ln37">/**</a>
<a name="ln38"> * @addtogroup app_sensor</a>
<a name="ln39"> */</a>
<a name="ln40">/** @{ */</a>
<a name="ln41">/**</a>
<a name="ln42"> * @file app_sensor.c</a>
<a name="ln43"> * @author Otso Jousimaa &lt;otso@ojousima.net&gt;</a>
<a name="ln44"> * @date 2020-04-16</a>
<a name="ln45"> * @copyright Ruuvi Innovations Ltd, license BSD-3-Clause.</a>
<a name="ln46"> *</a>
<a name="ln47"> * Initialize, configure and use sensors on board.</a>
<a name="ln48"> *</a>
<a name="ln49"> * Typical usage:</a>
<a name="ln50"> *</a>
<a name="ln51"> * @code{.c}</a>
<a name="ln52"> * TODO</a>
<a name="ln53"> * @endcode</a>
<a name="ln54"> */</a>
<a name="ln55">#define APP_SENSOR_HANDLE_UNUSED (0xFFU) //!&lt; Mark sensor unavailable with this handle.</a>
<a name="ln56"> </a>
<a name="ln57">#ifndef CEEDLING</a>
<a name="ln58">static</a>
<a name="ln59">#endif</a>
<a name="ln60">rt_sensor_ctx_t * m_sensors[SENSOR_COUNT]; //!&lt; Sensor APIs.</a>
<a name="ln61">static uint64_t vdd_update_time;           //!&lt; timestamp of VDD update.</a>
<a name="ln62">static uint32_t m_event_counter;           //!&lt; Number of events registered in app_sensor.</a>
<a name="ln63"> </a>
<a name="ln64">/**</a>
<a name="ln65"> * @brief Sensor operation, such as read or configure.</a>
<a name="ln66"> *</a>
<a name="ln67"> * These are used when outside central commands sensor to e.g. configure a sensor</a>
<a name="ln68"> * or read log. Operations are targeted on specific data types, such as</a>
<a name="ln69"> * temperature or acceleration. The operation is execcuted on first</a>
<a name="ln70"> * provider of given data if applicable.</a>
<a name="ln71"> *</a>
<a name="ln72"> * @param[in] reply_fp A function to which send operation acknowledgement.</a>
<a name="ln73"> * @param[in] fields Affected fields.</a>
<a name="ln74"> * @param[in] raw_message Original message triggering operation.</a>
<a name="ln75"> */</a>
<a name="ln76">typedef rd_status_t (*sensor_op) (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln77">                                  const rd_sensor_data_fields_t fields,</a>
<a name="ln78">                                  const uint8_t * const raw_message);</a>
<a name="ln79"> </a>
<a name="ln80">#if APP_SENSOR_BME280_ENABLED</a>
<a name="ln81">static rt_sensor_ctx_t bme280 =</a>
<a name="ln82">{</a>
<a name="ln83">    .sensor = {0},</a>
<a name="ln84">    .init = &amp;ri_bme280_init,</a>
<a name="ln85">    .configuration =</a>
<a name="ln86">    {</a>
<a name="ln87">        .dsp_function  = APP_SENSOR_BME280_DSP_FUNC,</a>
<a name="ln88">        .dsp_parameter = APP_SENSOR_BME280_DSP_PARAM,</a>
<a name="ln89">        .mode          = APP_SENSOR_BME280_MODE,</a>
<a name="ln90">        .resolution    = APP_SENSOR_BME280_RESOLUTION,</a>
<a name="ln91">        .samplerate    = APP_SENSOR_BME280_SAMPLERATE,</a>
<a name="ln92">        .scale         = APP_SENSOR_BME280_SCALE</a>
<a name="ln93">    },</a>
<a name="ln94">    .nvm_file = APP_FLASH_SENSOR_FILE,</a>
<a name="ln95">    .nvm_record = APP_FLASH_SENSOR_BME280_RECORD,</a>
<a name="ln96">#if RB_ENVIRONMENTAL_BME280_SPI_USE</a>
<a name="ln97">    .bus = RD_BUS_SPI,</a>
<a name="ln98">    .handle = RB_SPI_SS_ENVIRONMENTAL_PIN,</a>
<a name="ln99">#elif RB_ENVIRONMENTAL_BME280_I2C_USE</a>
<a name="ln100">    .bus = RD_BUS_I2C,</a>
<a name="ln101">    .handle = RB_BME280_I2C_ADDRESS,</a>
<a name="ln102">#else</a>
<a name="ln103">#   error &quot;No bus defined for BME280&quot;</a>
<a name="ln104">#endif</a>
<a name="ln105">    .pwr_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln106">    .pwr_on  = RI_GPIO_HIGH,</a>
<a name="ln107">    .fifo_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln108">    .level_pin = RI_GPIO_ID_UNUSED</a>
<a name="ln109">};</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">#if APP_SENSOR_LIS2DH12_ENABLED</a>
<a name="ln113">static rt_sensor_ctx_t lis2dh12 =</a>
<a name="ln114">{</a>
<a name="ln115">    .sensor = {0},</a>
<a name="ln116">    .init = &amp;ri_lis2dh12_init,</a>
<a name="ln117">    .configuration =</a>
<a name="ln118">    {</a>
<a name="ln119">        .dsp_function  = APP_SENSOR_LIS2DH12_DSP_FUNC,</a>
<a name="ln120">        .dsp_parameter = APP_SENSOR_LIS2DH12_DSP_PARAM,</a>
<a name="ln121">        .mode          = APP_SENSOR_LIS2DH12_MODE,</a>
<a name="ln122">        .resolution    = APP_SENSOR_LIS2DH12_RESOLUTION,</a>
<a name="ln123">        .samplerate    = APP_SENSOR_LIS2DH12_SAMPLERATE,</a>
<a name="ln124">        .scale         = APP_SENSOR_LIS2DH12_SCALE</a>
<a name="ln125">    },</a>
<a name="ln126">    .nvm_file = APP_FLASH_SENSOR_FILE,</a>
<a name="ln127">    .nvm_record = APP_FLASH_SENSOR_LIS2DH12_RECORD,</a>
<a name="ln128">    .bus = RD_BUS_SPI,</a>
<a name="ln129">    .handle = RB_SPI_SS_ACCELEROMETER_PIN,</a>
<a name="ln130">    .pwr_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln131">    .pwr_on  = RI_GPIO_HIGH,</a>
<a name="ln132">    .fifo_pin = RB_INT_FIFO_PIN,</a>
<a name="ln133">    .level_pin = RB_INT_LEVEL_PIN</a>
<a name="ln134">};</a>
<a name="ln135">#endif</a>
<a name="ln136"> </a>
<a name="ln137">#if APP_SENSOR_LIS2DW12_ENABLED</a>
<a name="ln138">static rt_sensor_ctx_t lis2dw12 =</a>
<a name="ln139">{</a>
<a name="ln140">    .sensor = {0},</a>
<a name="ln141">    .init = ri_lis2dw12_init,</a>
<a name="ln142">    .configuration = {0},</a>
<a name="ln143">    .nvm_file = APPLICATION_FLASH_SENSOR_FILE,</a>
<a name="ln144">    .nvm_record = APPLICATION_FLASH_SENSOR_LIS2DW12_RECORD,</a>
<a name="ln145">    .bus = RD_BUS_SPI,</a>
<a name="ln146">    .handle = RB_SPI_SS_ACCELEROMETER_PIN,</a>
<a name="ln147">    .pwr_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln148">    .pwr_on  = RI_GPIO_HIGH,</a>
<a name="ln149">    .fifo_pin = RB_INT_ACC1_PIN,</a>
<a name="ln150">    .level_pin = RB_INT_ACC2_PIN</a>
<a name="ln151">};</a>
<a name="ln152">#endif</a>
<a name="ln153"> </a>
<a name="ln154">#if APP_SENSOR_SHTCX_ENABLED</a>
<a name="ln155">static rt_sensor_ctx_t shtcx =</a>
<a name="ln156">{</a>
<a name="ln157">    .sensor = {0},</a>
<a name="ln158">    .init = &amp;ri_shtcx_init,</a>
<a name="ln159">    .configuration =</a>
<a name="ln160">    {</a>
<a name="ln161">        .dsp_function  = APP_SENSOR_SHTCX_DSP_FUNC,</a>
<a name="ln162">        .dsp_parameter = APP_SENSOR_SHTCX_DSP_PARAM,</a>
<a name="ln163">        .mode          = APP_SENSOR_SHTCX_MODE,</a>
<a name="ln164">        .resolution    = APP_SENSOR_SHTCX_RESOLUTION,</a>
<a name="ln165">        .samplerate    = APP_SENSOR_SHTCX_SAMPLERATE,</a>
<a name="ln166">        .scale         = APP_SENSOR_SHTCX_SCALE</a>
<a name="ln167">    },</a>
<a name="ln168">    .nvm_file = APP_FLASH_SENSOR_FILE,</a>
<a name="ln169">    .nvm_record = APP_FLASH_SENSOR_SHTCX_RECORD,</a>
<a name="ln170">    .bus = RD_BUS_I2C,</a>
<a name="ln171">    .handle = RB_SHTCX_I2C_ADDRESS,</a>
<a name="ln172">    .pwr_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln173">    .pwr_on  = RI_GPIO_HIGH,</a>
<a name="ln174">    .fifo_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln175">    .level_pin = RI_GPIO_ID_UNUSED</a>
<a name="ln176">};</a>
<a name="ln177">#endif</a>
<a name="ln178"> </a>
<a name="ln179">#if APP_SENSOR_PHOTO_ENABLED</a>
<a name="ln180">static rt_sensor_ctx_t photo =</a>
<a name="ln181">{</a>
<a name="ln182">    .sensor = {0},</a>
<a name="ln183">    .init = &amp;ri_adc_photo_init,</a>
<a name="ln184">    .configuration = {0},</a>
<a name="ln185">    .nvm_file = APP_FLASH_SENSOR_FILE,</a>
<a name="ln186">    .nvm_record = APP_FLASH_SENSOR_PHOTO_RECORD,</a>
<a name="ln187">    .bus = RD_BUS_NONE,</a>
<a name="ln188">    .handle = RB_PHOTO_ADC,</a>
<a name="ln189">    .pwr_pin = RB_PHOTO_PWR_PIN,</a>
<a name="ln190">    .pwr_on = RB_PHOTO_ACTIVE,</a>
<a name="ln191">    .fifo_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln192">    .level_pin = RI_GPIO_ID_UNUSED</a>
<a name="ln193">};</a>
<a name="ln194">#endif</a>
<a name="ln195"> </a>
<a name="ln196">#if APP_SENSOR_NTC_ENABLED</a>
<a name="ln197">static rt_sensor_ctx_t ntc =</a>
<a name="ln198">{</a>
<a name="ln199">    .sensor = {0},</a>
<a name="ln200">    .init = &amp;ri_adc_ntc_init,</a>
<a name="ln201">    .configuration = {0},</a>
<a name="ln202">    .nvm_file = APP_FLASH_SENSOR_FILE,</a>
<a name="ln203">    .nvm_record = APP_FLASH_SENSOR_NTC_RECORD,</a>
<a name="ln204">    .bus = RD_BUS_NONE,</a>
<a name="ln205">    .handle = RB_NTC_ADC,</a>
<a name="ln206">    .pwr_pin = RB_NTC_PWR_PIN,</a>
<a name="ln207">    .pwr_on = RB_NTC_ACTIVE,</a>
<a name="ln208">    .fifo_pin = RI_GPIO_ID_UNUSED,</a>
<a name="ln209">    .level_pin = RI_GPIO_ID_UNUSED</a>
<a name="ln210">};</a>
<a name="ln211">#endif</a>
<a name="ln212"> </a>
<a name="ln213">/** @brief Initialize sensor pointer array */</a>
<a name="ln214">#ifndef CEEDLING</a>
<a name="ln215">static</a>
<a name="ln216">#endif</a>
<a name="ln217">void m_sensors_init (void)</a>
<a name="ln218">{</a>
<a name="ln219">#if APP_SENSOR_TMP117_ENABLED</a>
<a name="ln220">    m_sensors[TMP117_INDEX] = tmp117;</a>
<a name="ln221">#endif</a>
<a name="ln222">#if APP_SENSOR_SHTCX_ENABLED</a>
<a name="ln223">    m_sensors[SHTCX_INDEX] = &amp;shtcx;</a>
<a name="ln224">#endif</a>
<a name="ln225">#if APP_SENSOR_BME280_ENABLED</a>
<a name="ln226">    m_sensors[BME280_INDEX] = &amp;bme280;</a>
<a name="ln227">#endif</a>
<a name="ln228">#if APP_SENSOR_NTC_ENABLED</a>
<a name="ln229">    m_sensors[NTC_INDEX] = &amp;ntc;</a>
<a name="ln230">#endif</a>
<a name="ln231">#if APP_SENSOR_PHOTO_ENABLED</a>
<a name="ln232">    m_sensors[PHOTO_INDEX] = &amp;photo;</a>
<a name="ln233">#endif</a>
<a name="ln234">#if APP_SENSOR_MCU_ENABLED</a>
<a name="ln235">    m_sensors[ENV_MCU_INDEX] = env_mcu;</a>
<a name="ln236">#endif</a>
<a name="ln237">#if APP_SENSOR_LIS2DH12_ENABLED</a>
<a name="ln238">    m_sensors[ LIS2DH12_INDEX] = &amp;lis2dh12;</a>
<a name="ln239">#endif</a>
<a name="ln240">#if APP_SENSOR_LIS2DW12_ENABLED</a>
<a name="ln241">    m_sensors[LIS2DW12_INDEX] = lis2dw12;</a>
<a name="ln242">#endif</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">void app_sensor_vdd_measure_isr (const ri_radio_activity_evt_t evt)</a>
<a name="ln246">{</a>
<a name="ln247">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln248"> </a>
<a name="ln249">    if (vdd_update_time &lt; ri_rtc_millis())</a>
<a name="ln250">    {</a>
<a name="ln251">        if (RI_RADIO_BEFORE == evt)</a>
<a name="ln252">        {</a>
<a name="ln253">            rd_sensor_configuration_t configuration =</a>
<a name="ln254">            {</a>
<a name="ln255">                .dsp_function  = RD_SENSOR_CFG_DEFAULT,</a>
<a name="ln256">                .dsp_parameter = RD_SENSOR_CFG_DEFAULT,</a>
<a name="ln257">                .mode          = RD_SENSOR_CFG_SINGLE,</a>
<a name="ln258">                .resolution    = RD_SENSOR_CFG_DEFAULT,</a>
<a name="ln259">                .samplerate    = RD_SENSOR_CFG_DEFAULT,</a>
<a name="ln260">                .scale         = RD_SENSOR_CFG_DEFAULT</a>
<a name="ln261">            };</a>
<a name="ln262">            err_code |= rt_adc_vdd_prepare (&amp;configuration);</a>
<a name="ln263">            RD_ERROR_CHECK (err_code, ~RD_ERROR_FATAL);</a>
<a name="ln264">        }</a>
<a name="ln265">        else</a>
<a name="ln266">        {</a>
<a name="ln267">            if (true == rt_adc_is_init())</a>
<a name="ln268">            {</a>
<a name="ln269">                vdd_update_time = ri_rtc_millis();</a>
<a name="ln270">                vdd_update_time += APP_BATTERY_SAMPLE_MS;</a>
<a name="ln271">                err_code |= rt_adc_vdd_sample();</a>
<a name="ln272">                RD_ERROR_CHECK (err_code, ~RD_ERROR_FATAL);</a>
<a name="ln273">            }</a>
<a name="ln274">        }</a>
<a name="ln275">    }</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">#ifndef CEEDLING</a>
<a name="ln279">static</a>
<a name="ln280">#endif</a>
<a name="ln281">void on_accelerometer_isr (const ri_gpio_evt_t event)</a>
<a name="ln282">{</a>
<a name="ln283">    if (RI_GPIO_SLOPE_LOTOHI == event.slope)</a>
<a name="ln284">    {</a>
<a name="ln285">        LOG (&quot;Movement \r\n&quot;);</a>
<a name="ln286">        app_sensor_event_increment();</a>
<a name="ln287">    }</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">static ri_i2c_frequency_t rb_to_ri_i2c_freq (unsigned int rb_freq)</a>
<a name="ln291">{</a>
<a name="ln292">    ri_i2c_frequency_t freq = RI_I2C_FREQUENCY_100k;</a>
<a name="ln293"> </a>
<a name="ln294">    switch (rb_freq)</a>
<a name="ln295">    {</a>
<a name="ln296">        case RB_I2C_FREQUENCY_400k:</a>
<a name="ln297">            freq = RI_I2C_FREQUENCY_400k;</a>
<a name="ln298">            break;</a>
<a name="ln299"> </a>
<a name="ln300">        case RB_I2C_FREQUENCY_250k:</a>
<a name="ln301">            freq = RI_I2C_FREQUENCY_250k;</a>
<a name="ln302">            break;</a>
<a name="ln303"> </a>
<a name="ln304">        case RB_I2C_FREQUENCY_100k:</a>
<a name="ln305"> </a>
<a name="ln306">        // Intentional fall-through.</a>
<a name="ln307">        default:</a>
<a name="ln308">            freq = RI_I2C_FREQUENCY_100k;</a>
<a name="ln309">            break;</a>
<a name="ln310">    }</a>
<a name="ln311"> </a>
<a name="ln312">    return freq;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">static ri_spi_frequency_t rb_to_ri_spi_freq (unsigned int rb_freq)</a>
<a name="ln316">{</a>
<a name="ln317">    ri_spi_frequency_t freq = RI_SPI_FREQUENCY_1M;</a>
<a name="ln318"> </a>
<a name="ln319">    switch (rb_freq)</a>
<a name="ln320">    {</a>
<a name="ln321">        case RB_SPI_FREQUENCY_8M:</a>
<a name="ln322">            freq = RI_SPI_FREQUENCY_8M;</a>
<a name="ln323">            break;</a>
<a name="ln324"> </a>
<a name="ln325">        case RB_SPI_FREQUENCY_4M:</a>
<a name="ln326">            freq = RI_SPI_FREQUENCY_4M;</a>
<a name="ln327">            break;</a>
<a name="ln328"> </a>
<a name="ln329">        case RB_SPI_FREQUENCY_2M:</a>
<a name="ln330">            freq = RI_SPI_FREQUENCY_2M;</a>
<a name="ln331">            break;</a>
<a name="ln332"> </a>
<a name="ln333">        case RB_SPI_FREQUENCY_1M:</a>
<a name="ln334"> </a>
<a name="ln335">        // Intentional fall-through.</a>
<a name="ln336">        default:</a>
<a name="ln337">            freq = RI_SPI_FREQUENCY_1M;</a>
<a name="ln338">            break;</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">    return freq;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">static rd_status_t app_sensor_buses_init (void)</a>
<a name="ln345">{</a>
<a name="ln346">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln347">    ri_gpio_id_t ss_pins[RB_SPI_SS_NUMBER] = RB_SPI_SS_LIST;</a>
<a name="ln348">    ri_spi_init_config_t spi_config =</a>
<a name="ln349">    {</a>
<a name="ln350">        .mosi = RB_SPI_MOSI_PIN,</a>
<a name="ln351">        .miso = RB_SPI_MISO_PIN,</a>
<a name="ln352">        .sclk = RB_SPI_SCLK_PIN,</a>
<a name="ln353">        .ss_pins = ss_pins,</a>
<a name="ln354">        .ss_pins_number = sizeof (ss_pins) / sizeof (ri_gpio_id_t),</a>
<a name="ln355">        // Assume mode 0 always.</a>
<a name="ln356">        .mode = RI_SPI_MODE_0,</a>
<a name="ln357">        .frequency = rb_to_ri_spi_freq (RB_SPI_FREQ)</a>
<a name="ln358">    };</a>
<a name="ln359">    ri_i2c_init_config_t i2c_config =</a>
<a name="ln360">    {</a>
<a name="ln361">        .sda = RB_I2C_SDA_PIN,</a>
<a name="ln362">        .scl = RB_I2C_SCL_PIN,</a>
<a name="ln363">        .frequency = rb_to_ri_i2c_freq (RB_I2C_FREQ)</a>
<a name="ln364">    };</a>
<a name="ln365"> </a>
<a name="ln366">    if ( (!ri_gpio_is_init()) || (!ri_gpio_interrupt_is_init()))</a>
<a name="ln367">    {</a>
<a name="ln368">        err_code |= RD_ERROR_INVALID_STATE;</a>
<a name="ln369">    }</a>
<a name="ln370">    else</a>
<a name="ln371">    {</a>
<a name="ln372">        err_code |= ri_spi_init (&amp;spi_config);</a>
<a name="ln373">        err_code |= ri_i2c_init (&amp;i2c_config);</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">    return err_code;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static rd_status_t app_sensor_buses_uninit (void)</a>
<a name="ln380">{</a>
<a name="ln381">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln382">    err_code |= ri_spi_uninit();</a>
<a name="ln383">    err_code |= ri_i2c_uninit ();</a>
<a name="ln384">    return err_code;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">static void app_sensor_rtc_init (void)</a>
<a name="ln388">{</a>
<a name="ln389">    // Returns invalid state if already init, not a problem here.</a>
<a name="ln390">    (void) ri_rtc_init();</a>
<a name="ln391">    rd_sensor_timestamp_function_set (&amp;ri_rtc_millis);</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394"> </a>
<a name="ln395">static void app_sensor_rtc_uninit (void)</a>
<a name="ln396">{</a>
<a name="ln397">    rd_sensor_timestamp_function_set (NULL);</a>
<a name="ln398">    (void) ri_rtc_uninit();</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">rd_status_t app_sensor_init (void)</a>
<a name="ln402">{</a>
<a name="ln403">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln404">    m_sensors_init();</a>
<a name="ln405">    err_code |= app_sensor_buses_init();</a>
<a name="ln406"> </a>
<a name="ln407">    if (RD_SUCCESS == err_code)</a>
<a name="ln408">    {</a>
<a name="ln409">        app_sensor_rtc_init();</a>
<a name="ln410"> </a>
<a name="ln411">        for (size_t ii = 0; ii &lt; SENSOR_COUNT; ii++)</a>
<a name="ln412">        {</a>
<a name="ln413">            rd_status_t init_code = RD_SUCCESS;</a>
<a name="ln414">            size_t retries = 0;</a>
<a name="ln415"> </a>
<a name="ln416">            // Enable power to sensor</a>
<a name="ln417">            if (m_sensors[ii]-&gt;pwr_pin != RI_GPIO_ID_UNUSED)</a>
<a name="ln418">            {</a>
<a name="ln419">                (void) ri_gpio_configure (m_sensors[ii]-&gt;pwr_pin,</a>
<a name="ln420">                                          RI_GPIO_MODE_OUTPUT_HIGHDRIVE);</a>
<a name="ln421">                (void) ri_gpio_write (m_sensors[ii]-&gt;pwr_pin, m_sensors[ii]-&gt;pwr_on);</a>
<a name="ln422">            }</a>
<a name="ln423"> </a>
<a name="ln424">            // Some sensors, such as accelerometer may fail on user moving the board. Retry.</a>
<a name="ln425">            do</a>
<a name="ln426">            {</a>
<a name="ln427">                init_code = rt_sensor_initialize (m_sensors[ii]);</a>
<a name="ln428">            } while ( (APP_SENSOR_SELFTEST_RETRIES &gt; retries++)</a>
<a name="ln429"> </a>
<a name="ln430">                      &amp;&amp; (RD_ERROR_SELFTEST == init_code));</a>
<a name="ln431"> </a>
<a name="ln432">            if (RD_SUCCESS == init_code)</a>
<a name="ln433">            {</a>
<a name="ln434">                // Check for a configuration in flash.</a>
<a name="ln435">                init_code = rt_sensor_load (m_sensors[ii]);</a>
<a name="ln436"> </a>
<a name="ln437">                // Configuration found, use it.</a>
<a name="ln438">                if (RD_SUCCESS == init_code)</a>
<a name="ln439">                {</a>
<a name="ln440">                    init_code = rt_sensor_configure (m_sensors[ii]);</a>
<a name="ln441">                }</a>
<a name="ln442">                // Configuration not found, use defaults, store to flash.</a>
<a name="ln443">                else</a>
<a name="ln444">                {</a>
<a name="ln445">                    init_code = rt_sensor_configure (m_sensors[ii]);</a>
<a name="ln446">                    rt_sensor_store (m_sensors[ii]);</a>
<a name="ln447">                }</a>
<a name="ln448">            }</a>
<a name="ln449">            else if (RD_ERROR_SELFTEST == init_code)</a>
<a name="ln450">            {</a>
<a name="ln451">                err_code |= RD_ERROR_SELFTEST;</a>
<a name="ln452">            }</a>
<a name="ln453">            // Mark unavailable sensor handles as unused.</a>
<a name="ln454">            else</a>
<a name="ln455">            {</a>
<a name="ln456">                m_sensors[ii]-&gt;handle = APP_SENSOR_HANDLE_UNUSED;</a>
<a name="ln457">            }</a>
<a name="ln458">        }</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">    return err_code;</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">rd_status_t app_sensor_uninit (void)</a>
<a name="ln465">{</a>
<a name="ln466">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln467"> </a>
<a name="ln468">    for (size_t ii = 0; ii &lt; SENSOR_COUNT; ii++)</a>
<a name="ln469">    {</a>
<a name="ln470">        if ( (NULL != m_sensors[ii]) &amp;&amp; rd_sensor_is_init (&amp; (m_sensors[ii]-&gt;sensor)))</a>
<a name="ln471">        {</a>
<a name="ln472">            m_sensors[ii]-&gt;sensor.uninit (&amp;m_sensors[ii]-&gt;sensor, m_sensors[ii]-&gt;bus,</a>
<a name="ln473">                                          m_sensors[ii]-&gt;handle);</a>
<a name="ln474"> </a>
<a name="ln475">            // Disable power to sensor</a>
<a name="ln476">            if (m_sensors[ii]-&gt;pwr_pin != RI_GPIO_ID_UNUSED)</a>
<a name="ln477">            {</a>
<a name="ln478">                (void) ri_gpio_write (m_sensors[ii]-&gt;pwr_pin, !m_sensors[ii]-&gt;pwr_on);</a>
<a name="ln479">                (void) ri_gpio_configure (m_sensors[ii]-&gt;pwr_pin, RI_GPIO_MODE_HIGH_Z);</a>
<a name="ln480">            }</a>
<a name="ln481">        }</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">    err_code |= app_sensor_buses_uninit();</a>
<a name="ln485">    app_sensor_rtc_uninit();</a>
<a name="ln486">    ri_radio_activity_callback_set (NULL);</a>
<a name="ln487">    return err_code;</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">rd_sensor_data_fields_t app_sensor_available_data (void)</a>
<a name="ln491">{</a>
<a name="ln492">    rd_sensor_data_fields_t available = {0};</a>
<a name="ln493"> </a>
<a name="ln494">    for (size_t ii = 0; ii &lt; SENSOR_COUNT; ii++)</a>
<a name="ln495">    {</a>
<a name="ln496">        if ( (NULL != m_sensors[ii])</a>
<a name="ln497">                &amp;&amp; rd_sensor_is_init (&amp; (m_sensors[ii]-&gt;sensor)))</a>
<a name="ln498">        {</a>
<a name="ln499">            available.bitfield |= m_sensors[ii]-&gt;sensor.provides.bitfield;</a>
<a name="ln500">        }</a>
<a name="ln501">    }</a>
<a name="ln502"> </a>
<a name="ln503">    return available;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">rd_status_t app_sensor_get (rd_sensor_data_t * const data)</a>
<a name="ln507">{</a>
<a name="ln508">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln509"> </a>
<a name="ln510">    for (size_t ii = 0; ii &lt; SENSOR_COUNT; ii++)</a>
<a name="ln511">    {</a>
<a name="ln512">        if ( (NULL != m_sensors[ii])</a>
<a name="ln513">                &amp;&amp; rd_sensor_is_init (&amp; (m_sensors[ii]-&gt;sensor)))</a>
<a name="ln514">        {</a>
<a name="ln515">            err_code |= m_sensors[ii]-&gt;sensor.data_get (data);</a>
<a name="ln516">        }</a>
<a name="ln517">    }</a>
<a name="ln518"> </a>
<a name="ln519">    return err_code;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">rd_sensor_t * app_sensor_find_provider (const rd_sensor_data_fields_t data)</a>
<a name="ln523">{</a>
<a name="ln524">    rd_sensor_t * provider = NULL;</a>
<a name="ln525"> </a>
<a name="ln526">    for (size_t ii = 0; (ii &lt; SENSOR_COUNT) &amp;&amp; (NULL == provider); ii++)</a>
<a name="ln527">    {</a>
<a name="ln528">        if ( (NULL != m_sensors[ii])</a>
<a name="ln529">                &amp;&amp; rd_sensor_is_init (&amp; (m_sensors[ii]-&gt;sensor))</a>
<a name="ln530">                &amp;&amp; (! (~ (m_sensors[ii]-&gt;sensor.provides.bitfield) &amp; data.bitfield)))</a>
<a name="ln531">        {</a>
<a name="ln532">            provider = &amp; (m_sensors[ii]-&gt;sensor);</a>
<a name="ln533">        }</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    return provider;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">void app_sensor_event_increment (void)</a>
<a name="ln540">{</a>
<a name="ln541">    m_event_counter++;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">uint32_t app_sensor_event_count_get (void)</a>
<a name="ln545">{</a>
<a name="ln546">    return m_event_counter;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">rd_status_t app_sensor_acc_thr_set (float * const threshold_g)</a>
<a name="ln551">{</a>
<a name="ln552">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln553">    const rd_sensor_data_fields_t acceleration =</a>
<a name="ln554">    {</a>
<a name="ln555">        .datas.acceleration_x_g = 1,</a>
<a name="ln556">        .datas.acceleration_y_g = 1,</a>
<a name="ln557">        .datas.acceleration_z_g = 1</a>
<a name="ln558">    };</a>
<a name="ln559">    const rd_sensor_t * const provider = app_sensor_find_provider (acceleration);</a>
<a name="ln560"> </a>
<a name="ln561">    if (RI_GPIO_ID_UNUSED == RB_INT_LEVEL_PIN)</a>
<a name="ln562">    {</a>
<a name="ln563">        err_code |= RD_ERROR_NOT_SUPPORTED;</a>
<a name="ln564">    }</a>
<a name="ln565">    else if ( (NULL == provider) || (NULL == provider-&gt;level_interrupt_set))</a>
<a name="ln566">    {</a>
<a name="ln567">        err_code |= RD_ERROR_NOT_SUPPORTED;</a>
<a name="ln568">    }</a>
<a name="ln569">    else if (NULL == threshold_g)</a>
<a name="ln570">    {</a>
<a name="ln571">        ri_gpio_interrupt_disable (RB_INT_LEVEL_PIN);</a>
<a name="ln572">        err_code |= provider-&gt;level_interrupt_set (false, threshold_g);</a>
<a name="ln573">    }</a>
<a name="ln574">    else if (0 &gt; *threshold_g)</a>
<a name="ln575">    {</a>
<a name="ln576">        err_code |= RD_ERROR_NOT_IMPLEMENTED;</a>
<a name="ln577">    }</a>
<a name="ln578">    else</a>
<a name="ln579">    {</a>
<a name="ln580">        err_code |= ri_gpio_interrupt_enable (RB_INT_LEVEL_PIN,</a>
<a name="ln581">                                              RI_GPIO_SLOPE_TOGGLE,</a>
<a name="ln582">                                              RI_GPIO_MODE_INPUT_NOPULL,</a>
<a name="ln583">                                              &amp;on_accelerometer_isr);</a>
<a name="ln584">        err_code |= provider-&gt;level_interrupt_set (true, threshold_g);</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">    return err_code;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">/**</a>
<a name="ln591"> * @brief Determine which fields are affected by given endpoint.</a>
<a name="ln592"> *</a>
<a name="ln593"> * @param[in] type Ruuvi Endpoint type.</a>
<a name="ln594"> * @return Ruuvi Driver fields corresponding to endpoint.</a>
<a name="ln595"> */</a>
<a name="ln596">static rd_sensor_data_fields_t re2rd_fields (const re_type_t type)</a>
<a name="ln597">{</a>
<a name="ln598">    rd_sensor_data_fields_t fields = {0};</a>
<a name="ln599"> </a>
<a name="ln600">    switch (type)</a>
<a name="ln601">    {</a>
<a name="ln602">        case RE_ACC_XYZ:</a>
<a name="ln603">            fields.datas.acceleration_x_g = 1;</a>
<a name="ln604">            fields.datas.acceleration_y_g = 1;</a>
<a name="ln605">            fields.datas.acceleration_z_g = 1;</a>
<a name="ln606">            break;</a>
<a name="ln607"> </a>
<a name="ln608">        case RE_ACC_X:</a>
<a name="ln609">            fields.datas.acceleration_x_g = 1;</a>
<a name="ln610">            break;</a>
<a name="ln611"> </a>
<a name="ln612">        case RE_ACC_Y:</a>
<a name="ln613">            fields.datas.acceleration_y_g = 1;</a>
<a name="ln614">            break;</a>
<a name="ln615"> </a>
<a name="ln616">        case RE_ACC_Z:</a>
<a name="ln617">            fields.datas.acceleration_z_g = 1;</a>
<a name="ln618">            break;</a>
<a name="ln619"> </a>
<a name="ln620">        case RE_GYR_XYZ:</a>
<a name="ln621">            fields.datas.gyro_x_dps = 1;</a>
<a name="ln622">            fields.datas.gyro_y_dps = 1;</a>
<a name="ln623">            fields.datas.gyro_z_dps = 1;</a>
<a name="ln624">            break;</a>
<a name="ln625"> </a>
<a name="ln626">        case RE_GYR_X:</a>
<a name="ln627">            fields.datas.gyro_x_dps = 1;</a>
<a name="ln628">            break;</a>
<a name="ln629"> </a>
<a name="ln630">        case RE_GYR_Y:</a>
<a name="ln631">            fields.datas.gyro_y_dps = 1;</a>
<a name="ln632">            break;</a>
<a name="ln633"> </a>
<a name="ln634">        case RE_GYR_Z:</a>
<a name="ln635">            fields.datas.gyro_z_dps = 1;</a>
<a name="ln636">            break;</a>
<a name="ln637"> </a>
<a name="ln638">        case RE_ENV_ALL:</a>
<a name="ln639">            fields.datas.humidity_rh = 1;</a>
<a name="ln640">            fields.datas.pressure_pa = 1;</a>
<a name="ln641">            fields.datas.temperature_c = 1;</a>
<a name="ln642">            break;</a>
<a name="ln643"> </a>
<a name="ln644">        case RE_ENV_HUMI:</a>
<a name="ln645">            fields.datas.humidity_rh = 1;</a>
<a name="ln646">            break;</a>
<a name="ln647"> </a>
<a name="ln648">        case RE_ENV_PRES:</a>
<a name="ln649">            fields.datas.pressure_pa = 1;</a>
<a name="ln650">            break;</a>
<a name="ln651"> </a>
<a name="ln652">        case RE_ENV_TEMP:</a>
<a name="ln653">            fields.datas.temperature_c = 1;</a>
<a name="ln654">            break;</a>
<a name="ln655"> </a>
<a name="ln656">        default:</a>
<a name="ln657">            RD_ERROR_CHECK (RD_ERROR_NOT_IMPLEMENTED, ~RD_ERROR_FATAL);</a>
<a name="ln658">            break;</a>
<a name="ln659">    }</a>
<a name="ln660"> </a>
<a name="ln661">    return fields;</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">/**</a>
<a name="ln665"> * @brief Convert Ruuvi Driver data type to Ruuvi endpoint header.</a>
<a name="ln666"> *</a>
<a name="ln667"> * @param[in] field Data field to convert, exactly one must be set.</a>
<a name="ln668"> * @return Ruuvi Endpoint constant corresponding to field. 0 if field is invalid.</a>
<a name="ln669"> */</a>
<a name="ln670">static uint8_t rd2re_fields (const rd_sensor_data_bitfield_t fields)</a>
<a name="ln671">{</a>
<a name="ln672">    // Implementing field-&gt;header assigments as a look-up table would</a>
<a name="ln673">    // rely on specific representation of bitfield at compile time.</a>
<a name="ln674">    // Little-endian, big-endian, BE-8, BE-32 etc. Using if-else</a>
<a name="ln675">    // here for robustness.</a>
<a name="ln676">    uint8_t header_value = 0;</a>
<a name="ln677"> </a>
<a name="ln678">    if (fields.acceleration_x_g) { header_value = RE_ACC_X; }</a>
<a name="ln679">    else if (fields.acceleration_y_g) { header_value = RE_ACC_Y; }</a>
<a name="ln680">    else if (fields.acceleration_z_g) { header_value = RE_ACC_Z; }</a>
<a name="ln681">    else if (fields.gyro_x_dps) { header_value = RE_GYR_X; }</a>
<a name="ln682">    else if (fields.gyro_y_dps) { header_value = RE_GYR_Y; }</a>
<a name="ln683">    else if (fields.gyro_z_dps) { header_value = RE_GYR_Z; }</a>
<a name="ln684">    else if (fields.humidity_rh) { header_value = RE_ENV_HUMI; }</a>
<a name="ln685">    else if (fields.pressure_pa) { header_value = RE_ENV_PRES; }</a>
<a name="ln686">    else if (fields.temperature_c) { header_value = RE_ENV_TEMP; }</a>
<a name="ln687">    else</a>
<a name="ln688">    {</a>
<a name="ln689">        // No action needed</a>
<a name="ln690">    }</a>
<a name="ln691"> </a>
<a name="ln692">    return header_value;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">/**</a>
<a name="ln696"> * @brief encode log element into given buffer.</a>
<a name="ln697"> *</a>
<a name="ln698"> * @param[in] buffer Buffer to encode data into.</a>
<a name="ln699"> * @param[in] timestamp_ms Float value to encode.</a>
<a name="ln700"> * @param[in] data Float value to encode.</a>
<a name="ln701"> * @param[in] type Type of data to encode. Only one type/message is implemented.</a>
<a name="ln702"> *</a>
<a name="ln703"> * @note This function will not set the destination endpoint in buffer.</a>
<a name="ln704"> * @retval RD_SUCCESS Data was encoded successfully.</a>
<a name="ln705"> * @retval RD_ERROR_NULL Buffer or data was NULL.</a>
<a name="ln706"> * @retval RD_ERROR_INVALID_PARAM Type had no field set.</a>
<a name="ln707"> * @retval RD_ERROR_NOT_IMPLEMENTED Type had &gt; 1 field set or encoding type is not implemented.</a>
<a name="ln708"> */</a>
<a name="ln709">static rd_status_t app_sensor_encode_log (uint8_t * const buffer,</a>
<a name="ln710">        const uint64_t timestamp_ms,</a>
<a name="ln711">        const float data,</a>
<a name="ln712">        const rd_sensor_data_bitfield_t type)</a>
<a name="ln713">{</a>
<a name="ln714">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln715">    const uint8_t source = rd2re_fields (type);</a>
<a name="ln716"> </a>
<a name="ln717">    if (0 != source)</a>
<a name="ln718">    {</a>
<a name="ln719">        re_log_write_header (buffer, source);</a>
<a name="ln720">        re_log_write_timestamp (buffer, timestamp_ms);</a>
<a name="ln721">        re_log_write_data (buffer, data, source);</a>
<a name="ln722">    }</a>
<a name="ln723">    else</a>
<a name="ln724">    {</a>
<a name="ln725">        err_code |= RD_ERROR_INVALID_PARAM;</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">    return err_code;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">/**</a>
<a name="ln734"> * if valid data in sample</a>
<a name="ln735"> * parse data type</a>
<a name="ln736"> * parse data value</a>
<a name="ln737"> * format msg</a>
<a name="ln738"> * send msg</a>
<a name="ln739"> */</a>
<a name="ln740">static rd_status_t send_field (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln741">                               const uint8_t * const raw_message,</a>
<a name="ln742">                               const rd_sensor_data_bitfield_t type,</a>
<a name="ln743">                               const float value,</a>
<a name="ln744">                               const int64_t real_time_ms)</a>
<a name="ln745">{</a>
<a name="ln746">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln747">    ri_comm_message_t msg = {0};</a>
<a name="ln748">    err_code |= app_sensor_encode_log (msg.data, real_time_ms, value,</a>
<a name="ln749">                                       type);</a>
<a name="ln750"> </a>
<a name="ln751">    if (RD_SUCCESS == err_code)</a>
<a name="ln752">    {</a>
<a name="ln753">        msg.repeat_count = 1;</a>
<a name="ln754">        msg.data_length = RE_STANDARD_MESSAGE_LENGTH;</a>
<a name="ln755">        msg.data[RE_STANDARD_DESTINATION_INDEX] = raw_message[RE_STANDARD_SOURCE_INDEX];</a>
<a name="ln756">        err_code |= app_comms_blocking_send (reply_fp, &amp;msg);</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    return err_code;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">/**</a>
<a name="ln763"> * @brief Send data element.</a>
<a name="ln764"> *</a>
<a name="ln765"> * This function sends given data element to given reply function pointer.</a>
<a name="ln766"> *</a>
<a name="ln767"> * @param[in] reply_fp Function pointer to reply to.</a>
<a name="ln768"> * @param[in] raw_message original query from remote.</a>
<a name="ln769"> * @param[in] sample Data sample to send.</a>
<a name="ln770"> * @param[in] time_offset_ms Offset between tag time and real time.</a>
<a name="ln771"> * @retval RD_SUCCESS reply was sent successfully.</a>
<a name="ln772"> * @retval error code from reply_fp in case of error.</a>
<a name="ln773"> *</a>
<a name="ln774"> * @note This function blocks until reply_fp returns something else than</a>
<a name="ln775"> *       RD_ERROR_NO_MEM.</a>
<a name="ln776"> */</a>
<a name="ln777">static rd_status_t app_sensor_send_data (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln778">        const uint8_t * const raw_message,</a>
<a name="ln779">        const rd_sensor_data_t * const sample,</a>
<a name="ln780">        const int64_t time_offset_ms)</a>
<a name="ln781">{</a>
<a name="ln782">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln783">    const uint8_t fieldcount = rd_sensor_data_fieldcount (sample);</a>
<a name="ln784">    int64_t real_time_ms = 0;</a>
<a name="ln785"> </a>
<a name="ln786">    if ( (0 - time_offset_ms) &lt; (int64_t) sample-&gt;timestamp_ms)</a>
<a name="ln787">    {</a>
<a name="ln788">        real_time_ms = sample-&gt;timestamp_ms + time_offset_ms;</a>
<a name="ln789">    }</a>
<a name="ln790"> </a>
<a name="ln791">    for (uint8_t ii = 0; ii &lt; fieldcount; ii++)</a>
<a name="ln792">    {</a>
<a name="ln793">        if (rd_sensor_has_valid_data (sample, ii))</a>
<a name="ln794">        {</a>
<a name="ln795">            rd_sensor_data_bitfield_t type = rd_sensor_field_type (sample, ii);</a>
<a name="ln796">            err_code |= send_field (reply_fp, raw_message,</a>
<a name="ln797">                                    type, sample-&gt;data[ii], real_time_ms);</a>
<a name="ln798">        }</a>
<a name="ln799">    }</a>
<a name="ln800"> </a>
<a name="ln801">    return err_code;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">/**</a>
<a name="ln805"> * @brief Send no more sensor log data message.</a>
<a name="ln806"> * TODO -refactor encoding to endpoints.</a>
<a name="ln807"> * TODO -refactor into comms</a>
<a name="ln808"> */</a>
<a name="ln809">static rd_status_t app_sensor_send_eof (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln810">                                        const uint8_t * const raw_message)</a>
<a name="ln811">{</a>
<a name="ln812">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln813">    ri_comm_message_t msg = {0};</a>
<a name="ln814">    msg.data_length = RE_STANDARD_MESSAGE_LENGTH;</a>
<a name="ln815">    msg.data[RE_STANDARD_DESTINATION_INDEX] = raw_message[RE_STANDARD_SOURCE_INDEX];</a>
<a name="ln816">    msg.data[RE_STANDARD_SOURCE_INDEX] = raw_message[RE_STANDARD_DESTINATION_INDEX];</a>
<a name="ln817">    msg.data[RE_STANDARD_OPERATION_INDEX] = RE_STANDARD_LOG_VALUE_WRITE;</a>
<a name="ln818">    memset (&amp;msg.data[RE_STANDARD_HEADER_LENGTH], 0xFF, RE_STANDARD_PAYLOAD_LENGTH);</a>
<a name="ln819">    app_comms_blocking_send (reply_fp, &amp;msg);</a>
<a name="ln820">    return err_code;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">/**</a>
<a name="ln824"> * @brief Log read sensor op.</a>
<a name="ln825"> *</a>
<a name="ln826"> * @ref sensor_op.</a>
<a name="ln827"> *</a>
<a name="ln828"> * @param[in] reply_fp Function pointer to which send logs.</a>
<a name="ln829"> * @param[fields] Fields to read.</a>
<a name="ln830"> * @param[raw_message] Original message from remote.</a>
<a name="ln831"> * @retval RD_SUCCESS on success.</a>
<a name="ln832"> * @retval RD_ERROR_INVALID_PARAM if start of logs is after current time.</a>
<a name="ln833"> * @retval error code from reply_fp if reply fails.</a>
<a name="ln834"> *</a>
<a name="ln835"> * @note This function blocks until all requested logs are sent and will therefore</a>
<a name="ln836"> *       block for a long time.</a>
<a name="ln837"> */</a>
<a name="ln838">static rd_status_t app_sensor_log_read (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln839">                                        const rd_sensor_data_fields_t fields,</a>
<a name="ln840">                                        const uint8_t * const raw_message)</a>
<a name="ln841">{</a>
<a name="ln842">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln843">    rd_sensor_data_t sample = {0};</a>
<a name="ln844">    </a>
<a name="ln845">    sample.fields = fields;</a>
<a name="ln846">    float data[rd_sensor_data_fieldcount (&amp;sample)];</a>
<a name="ln847">    sample.data = data;</a>
<a name="ln848">    // Parse start, end times.</a>
<a name="ln849">    uint32_t current_time_s = re_std_log_current_time (raw_message);</a>
<a name="ln850">    uint32_t start_s = re_std_log_start_time (raw_message);</a>
<a name="ln851">    uint32_t sent_elements = 0;</a>
<a name="ln852">    const uint64_t system_time_ms = ri_rtc_millis();</a>
<a name="ln853"> </a>
<a name="ln854">    // Cannot have start_s &gt;= current_time_s</a>
<a name="ln855">    if (current_time_s &gt; start_s)</a>
<a name="ln856">    {</a>
<a name="ln857">        // Parse offset to system clock - flows over in 68 years.</a>
<a name="ln858">        LOG (&quot;Sending logged data\r\n&quot;);</a>
<a name="ln859">        int32_t system_time_s = (int32_t) (system_time_ms/ 1000U);</a>
<a name="ln860">        int64_t offset_ms = ( (int64_t) current_time_s - (int64_t) system_time_s) *</a>
<a name="ln861">                            (int64_t) 1000;</a>
<a name="ln862">        int64_t time_diff_ms = (current_time_s - start_s) * 1000U;</a>
<a name="ln863"> </a>
<a name="ln864">        // First sample to send in real time</a>
<a name="ln865">        sample.timestamp_ms = (start_s * 1000U);</a>
<a name="ln866">        // Offset sample time to system clock.</a>
<a name="ln867">        if (time_diff_ms &gt; system_time_ms)</a>
<a name="ln868">        {</a>
<a name="ln869">            sample.timestamp_ms = 0;</a>
<a name="ln870">        }</a>
<a name="ln871">        else</a>
<a name="ln872">        {</a>
<a name="ln873">            sample.timestamp_ms = system_time_ms - time_diff_ms;</a>
<a name="ln874">        }</a>
<a name="ln875"> </a>
<a name="ln876">        app_log_read_state_t rs = </a>
<a name="ln877">        {</a>
<a name="ln878">            .oldest_element_ms = sample.timestamp_ms,</a>
<a name="ln879">            .element_idx = 0,</a>
<a name="ln880">            .page_idx = 0</a>
<a name="ln881">        };</a>
<a name="ln882"> </a>
<a name="ln883">        while (RD_SUCCESS == err_code)</a>
<a name="ln884">        {</a>
<a name="ln885">            // Reset data validity</a>
<a name="ln886">            sample.valid.bitfield = 0;</a>
<a name="ln887">            // Timestamp and fields are set in log read function.</a>
<a name="ln888">            err_code |= app_log_read (&amp;sample, &amp;rs);</a>
<a name="ln889"> </a>
<a name="ln890">            // If data element was found, send log element.</a>
<a name="ln891">            if (RD_SUCCESS == err_code)</a>
<a name="ln892">            {</a>
<a name="ln893">                err_code |= app_sensor_send_data (reply_fp, raw_message,</a>
<a name="ln894">                                                  &amp;sample, offset_ms);</a>
<a name="ln895">                sent_elements++;</a>
<a name="ln896">                LOGD (&quot;S&quot;);</a>
<a name="ln897">            }</a>
<a name="ln898">            else if (RD_ERROR_NOT_FOUND == err_code)</a>
<a name="ln899">            {</a>
<a name="ln900">                err_code |= app_sensor_send_eof (reply_fp, raw_message);</a>
<a name="ln901">                char msg[128];</a>
<a name="ln902">                snprintf (msg, sizeof (msg), &quot;Logged data sent: %lu elements\r\n&quot;, sent_elements);</a>
<a name="ln903">                LOG (msg);</a>
<a name="ln904">                sent_elements = 0;</a>
<a name="ln905">            }</a>
<a name="ln906">            else</a>
<a name="ln907">            {</a>
<a name="ln908">                // No action needed, error code gets returned to caller.</a>
<a name="ln909">            }</a>
<a name="ln910">        }</a>
<a name="ln911">    }</a>
<a name="ln912">    // Start time &gt;= current time</a>
<a name="ln913">    else</a>
<a name="ln914">    {</a>
<a name="ln915">        err_code |= RD_ERROR_INVALID_PARAM;</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">    // Send op status, remove expected not found</a>
<a name="ln919">    err_code &amp;= ~RD_ERROR_NOT_FOUND;</a>
<a name="ln920">    return err_code;</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">rd_status_t app_sensor_handle (const ri_comm_xfer_fp_t reply_fp,</a>
<a name="ln924">                               const uint8_t * const raw_message,</a>
<a name="ln925">                               const uint16_t data_len)</a>
<a name="ln926">{</a>
<a name="ln927">    rd_status_t err_code = RD_SUCCESS;</a>
<a name="ln928"> </a>
<a name="ln929">    if (NULL == raw_message)</a>
<a name="ln930">    {</a>
<a name="ln931">        err_code |= RD_ERROR_NULL;</a>
<a name="ln932">    }</a>
<a name="ln933">    else if (data_len &lt; RE_STANDARD_MESSAGE_LENGTH)</a>
<a name="ln934">    {</a>
<a name="ln935">        err_code |= RD_ERROR_DATA_SIZE;</a>
<a name="ln936">    }</a>
<a name="ln937">    else</a>
<a name="ln938">    {</a>
<a name="ln939">        // Parse affected fields. It's ok to have unspecified value here,</a>
<a name="ln940">        // in that case fields end up being empty and error is reported via reply_fp.</a>
<a name="ln941">        re_type_t type = (re_type_t) raw_message[RE_STANDARD_DESTINATION_INDEX];</a>
<a name="ln942">        rd_sensor_data_fields_t target_fields = re2rd_fields (type);</a>
<a name="ln943">        // Parse desired operation.</a>
<a name="ln944">        re_op_t op = (re_op_t) raw_message[RE_STANDARD_OPERATION_INDEX];</a>
<a name="ln945"> </a>
<a name="ln946">        // If target and op are valid, execute.</a>
<a name="ln947">        switch (op)</a>
<a name="ln948">        {</a>
<a name="ln949">            case RE_STANDARD_LOG_VALUE_READ:</a>
<a name="ln950">                err_code |= app_sensor_log_read (reply_fp,</a>
<a name="ln951">                                                 target_fields, raw_message);</a>
<a name="ln952">                break;</a>
<a name="ln953"> </a>
<a name="ln954">            default:</a>
<a name="ln955">                // Reply with error on unknown op.</a>
<a name="ln956">                break;</a>
<a name="ln957">        }</a>
<a name="ln958">    }</a>
<a name="ln959"> </a>
<a name="ln960">    return err_code;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">#ifdef RUUVI_RUN_TESTS</a>
<a name="ln964">void app_sensor_ctx_get (rt_sensor_ctx_t *** p_sensors, size_t * num_sensors)</a>
<a name="ln965">{</a>
<a name="ln966">    *p_sensors = m_sensors;</a>
<a name="ln967">    *num_sensors = SENSOR_COUNT;</a>
<a name="ln968">}</a>
<a name="ln969">#endif</a>
<a name="ln970"> </a>
<a name="ln971">/** @} */</a>

</code></pre>
<div class="balloon" rel="98"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="132"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '==' operator should have the same essential type. The current types are: 'signed' and 'Boolean'.</p></div>
<div class="balloon" rel="347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="350"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="352"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="411"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '!=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="421"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the 'm_sensors[ii]->pwr_on' expression should not be converted from the essential 'ri_gpio_state_t' type to the essential 'unsigned' type.</p></div>
<div class="balloon" rel="456"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '(0xFFU)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="468"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="476"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '!=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The 'm_sensors[ii]->pwr_on' operand of the '!' operator should not have the essential 'ri_gpio_state_t' type.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2570/" target="_blank">V2570</a> Operands of the '!' operator should have bool essential type.</p></div>
<div class="balloon" rel="478"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '!m_sensors[ii]->pwr_on' expression should not be converted from the essential 'Boolean' type to the essential 'unsigned' type.</p></div>
<div class="balloon" rel="494"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="510"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '<' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> Operand of the '!' operator should have an appropriate essential type.</p></div>
<div class="balloon" rel="530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2570/" target="_blank">V2570</a> Operands of the '!' operator should have bool essential type.</p></div>
<div class="balloon" rel="561"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="574"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '>' operator should have the same essential type. The current types are: 'signed' and 'floating'.</p></div>
<div class="balloon" rel="580"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2544/" target="_blank">V2544</a> The left operand '(0)' of the '<<' operator should not have the essential 'signed' type.</p></div>
<div class="balloon" rel="603"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="605"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="613"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="617"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="621"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="622"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="623"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="627"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="631"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="635"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="640"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="645"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="649"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="653"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="680"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="681"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="682"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="683"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="684"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="717"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '!=' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="753"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="754"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '((3U) + (8U))' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '+' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the 'sample->timestamp_ms + time_offset_ms' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="814"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '((3U) + (8U))' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="817"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '(0x10U)' expression should not be converted to the narrower essential 'unsigned' type.</p></div>
<div class="balloon" rel="862"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> The value of the '(current_time_s - start_s) * 1000U' expression should not be converted from the essential 'unsigned' type to the essential 'signed' type.</p></div>
<div class="balloon" rel="867"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '>' operator should have the same essential type. The current types are: 'signed' and 'unsigned'.</p></div>
<div class="balloon" rel="869"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="873"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '-' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="886"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="902"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'snprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2568/" target="_blank">V2568</a> Both operands of the '=' operator should have the same essential type. The current types are: 'unsigned' and 'signed'.</p></div>
<div class="balloon" rel="941"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2531/" target="_blank">V2531</a> The 'raw_message[(0U)]' expression of the essential 'unsigned' type should not be cast to the essential 're_type_t' type.</p></div>
<div class="balloon" rel="944"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2531/" target="_blank">V2531</a> The 'raw_message[(2U)]' expression of the essential 'unsigned' type should not be cast to the essential 're_op_t' type.</p></div>
<div class="balloon" rel="949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v2572/" target="_blank">V2572</a> Constant expression of the case label of the essential 'unsigned' type should not be converted to the essential 're_op_t' type of the controlling expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
